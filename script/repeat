#!perl

use 5.010001;
use strict;
use warnings;
use Log::ger;

use Getopt::Long::Less;

# AUTHORITY
# DATE
# DIST
# VERSION

our %Opts = (
    n => undef,
    until => undef,
    max => undef,

    delay => undef,
    delay_max => undef,
    delay_strategy => undef,

    bail => 0,
    dry_run => 0,
    dry_run_delay => 0,
);

my $Exit_Code = 0;

sub parse_cmdline {
    my $res = GetOptions(
        'n=i'              => \$Opts{n},
        'until=s'          => sub {
            require DateTime::Format::Natural;
            my $dt = DateTime::Format::Natural->new->parse_datetime($_[1]);
            warn "TZ is not set!" unless $ENV{TZ};
            $dt->set_time_zone($ENV{TZ});
            log_debug "--until is set to %s (%.3f)", "$dt", $dt->epoch;
            $Opts{until} = $dt->epoch;
        },
        'max=i'            => \$Opts{max},

        'delay|d=f'        => \$Opts{delay},
        'delay-min=f'      => \$Opts{delay_min},
        'delay-max=f'      => \$Opts{delay_max},
        'delay-strategy=s' => sub {
            no strict 'refs';  ## no critic: TestingAndDebugging::ProhibitNoStrict
            my $s = $_[1];
            my ($mod, $args) = $s =~ /\A(\w+(?:\::\w+)*)(?:[=,](.*))?/;
            $args //= ''; $args = { split /,/, $args };
            $mod = "Algorithm::Backoff::$mod";
            (my $modpm = "$mod.pm") =~ s!::!/!g;
            require $modpm;
            $s = $mod->new(%$args);

            $Opts{delay_strategy} = $s;
        },

        'bail!'            => \$Opts{bail},
        'dry-run!'         => \$Opts{dry_run},
        'dry-run-delay'    => \$Opts{dry_run_delay},
        'help|h|?'         => sub {
            print <<USAGE;
Usage:
  repeat [repeat options] -- [command] [command options ...]
  repeat --help, -h, -?
Options:
  -n=i
  --until=s
  --max=i
  --delay=f, -d
  --delay-strategy=s
  --(no-)bail
  --(no-)dry-run
  --dry-run-sleep
For more details, see the manpage/documentation.
USAGE
            exit 0;
        },
    );
    exit 99 if !$res;
    unless ((defined $Opts{n}) xor (defined $Opts{until})) {
        warn "repeat: Please specify -n or --until\n";
        exit 99;
    }
    if (defined $Opts{delay_min} && !defined $Opts{delay_max}) {
        warn "repeat: --delay-max must be specified\n";
        exit 99;
    }
    $Opts{delay_min} //= 0;
    unless (@ARGV) {
        warn "repeat: No command specified\n";
        exit 99;
    }
}

sub run_cmd {
    my ($is_dry_run, $i, $max) = @_;

    if (log_is_debug()) {
        log_debug "\%s[repeat: %d%s] Executing command: %s",
            ($is_dry_run ? "[DRY_RUN]" : ""),
            $i,
            (defined($max) ? "/$max" : ""),
            join(" ", @ARGV);
    }
    unless ($is_dry_run) {
        system @ARGV;
        $Exit_Code = $? >> 8;
        log_debug "exit code is $Exit_Code";
    }
}

sub run {
    require Time::HiRes;

    my $i = 0;
    my $now;
    while (1) {
        $i++;

        # check whether we should exit
        $now = Time::HiRes::time();
        if (defined $Opts{n} && $i > $Opts{n}) {
            log_debug "Number of times (%d) exceeded", $Opts{n};
            goto EXIT;
        }
        if (defined $Opts{max} && $i > $Opts{max}) {
            log_debug "Maximum number of times (%d) exceeded", $Opts{max};
            goto EXIT;
        }
        if (defined $Opts{until}) {
            log_debug "Comparing current time ($now) with --until ($Opts{until})";
            if ($now > $Opts{until}) {
                log_debug "--until time (%f) exceeded", $Opts{until};
                goto EXIT;
            }
        }

        run_cmd($Opts{dry_run}, $i, $Opts{n} // $Opts{max});

        if ($Opts{bail} && $Exit_Code) {
            log_debug "exit code is non-zero, bailing ...";
            goto EXIT;
        }

        # delay
        if (defined $Opts{delay}) {
            if ($Opts{dry_run} && $Opts{dry_run_delay}) {
                log_debug "[DRY_RUN] Sleeping for %.3f second(s)", $Opts{delay};
            } else {
                log_debug "Sleeping for %.3f second(s)", $Opts{delay};
                Time::HiRes::sleep($Opts{delay});
            }
        } elsif (defined $Opts{delay_max}) {
            my $delay = $Opts{delay_min} + rand()*($Opts{delay_max} - $Opts{delay_min});
            if ($Opts{dry_run} && $Opts{dry_run_delay}) {
                log_debug "[DRY_RUN] Sleeping for %.3f second(s)", $delay;
            } else {
                log_debug "Sleeping for %.3f second(s)", $delay;
                Time::HiRes::sleep($delay);
            }
        } elsif (defined $Opts{delay_strategy}) {
            my $delay = $Opts{delay_strategy}->failure;
            if ($Opts{dry_run} && $Opts{dry_run_delay}) {
                log_debug "[DRY_RUN] Sleeping for %.3f second(s)", $delay;
            } else {
                log_debug "Sleeping for %.3f second(s)", $delay;
                Time::HiRes::sleep($delay);
            }
        }
    } # while (1)

  EXIT:
    log_debug "Exiting with exit code $Exit_Code ...";
    exit $Exit_Code;
}

# MAIN

parse_cmdline();

run();
exit $Exit_Code;

1;
# ABSTRACT: Repeat a command a number of times
# PODNAME:

=head1 SYNOPSIS

Usage:

 % repeat [REPEAT OPTIONS] -- [PROGRAM] [PROGRAM OPTIONS ...]

Below are some examples.

This will run C<somecmd> 10 times:

 % repeat -n10 -- somecmd --cmdopt

This will run C<somecmd> 10 times with a delay of 2 seconds in between:

 % repeat -n10 -d2 -- somecmd --cmdopt

This will repeatedly run C<somecmd> until tomorrow at 10am with a delay of
between 2 and 10 seconds in between (keywords: jitter):

 % repeat --until 'tomorrow 10AM' --delay-min=2 --delay-max=10 -- somecmd --cmdopt

This will run C<somecmd> 10 times with exponentially increasing delay from 1, 2,
4, and so on:

 % repeat -n10 --delay-strategy=Exponential=initial_delay,1 -- somecmd --cmdopt

Dry-run mode and show debugging messages: do not actually run the command, just
show it in the log (require L<Log::ger::Screen>).

 % TRACE=1 PERL5OPT=-MLog::ger::Screen repeat -n10 --dry-run -- foo


=head1 DESCRIPTION

C<repeat> is a CLI utility that lets you repeat running a command a number of
times. In its most basic usage, it simplifies this shell construct:

 % for i in `seq 1 10`; do somecmd --cmdopt; done

into:

 % repeat -n10 -- somecmd --cmdopt

You can either specify a fixed number of times to repeat (C<-n>) or until a
certain point of time (C<--until>) with an optional maximum number of repetition
(C<--max>).

Delay between command can be specified as a fixed number of seconds (C<--delay>)
or a random range of seconds (C<--delay-min>, C<--delay-max>) or using a backoff
strategy (see L<Algorithm::Backoff>).

You can opt to bail immediately after a failure (C<--bail>).


=head1 OPTIONS

=over

=item * --help, -h, -?

=item * -n

Uint. Number of times to run the command. Alternatively, you can use C<--until>
(with optional C<--max>) instead.

=item * --until

String representation of time. Will be parsed using
L<DateTime::Format::Natural>. Alternatively, you can use C<-n> instead.

=item * --max

Uint. When C<--until> is specified, specify maximum number of repetition.

=item * --delay, -d

Float. Number of seconds to delay between running a command. Alternatively, you
can specify C<--delay-min> and C<--delay-max>, or C<--delay-strategy>.

=item * --delay-min

Float.

=item * --delay-max

Float.

=item * --delay-strategy

Str. Pick a backoff strategy from L<Algorithm::Backoff>. It should be a module
name under C<Algorithm::Backoff::> namespace, without the prefix, optionally
followed by C<,> (or C<=>) and a comma-separated list of arguments. For example:

 Exponential=initial_delay,1,max_delay,10

Note that the failure delay values are used as the delays.

Also note that the dependency is not specified explicitly; you have to install
it yourself.

=item * --bail

=item * --dry-run

Dry-run mode. Don't actually run the command, just show it in the log. But
delays will be performed; use C<--dry-run-delay> to skip delaying also.

=item * --dry-run-delay

Dry-run mode for delay. Don't actually delay, just show it in the log.

=back


=head1 ENVIRONMENT


=head1 SEE ALSO

L<norepeat> from L<App::norepeat>.

L<retry> from L<App::AlgorithmBackoffUtils>.

=cut
